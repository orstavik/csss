<style>
  body:hover div {
    transform: translateX(400px);
  }

  canvas {
    display: block;
  }

  div {
    transition-duration: 5s;
    transition-property: transform;
    width: fit-content;
    background: lightblue;
    margin: 10px;
    border: 1px solid blue;
    display: flex;
  }
</style>
<h1>hello sunshine</h1>


<script>
  function cubicBezier([x0, y0, x1, y1, x2, y2, x3, y3], t) {
    const u = 1 - t;
    const tt = t * t, uu = u * u;
    const uuu = uu * u, ttt = tt * t;
    const uut3 = 3 * uu * t, utt3 = 3 * u * tt;
    const x = uuu * x0 + uut3 * x1 + utt3 * x2 + ttt * x3;
    const y = uuu * y0 + uut3 * y1 + utt3 * y2 + ttt * y3;
    return { x, y };
  }

  function getTPoints(curve, density = 500) {
    return Array.from({ length: density + 1 }, (_, i) => cubicBezier(curve, i / density));
  }

  function spreadYValues(points, spread = 100) {
    if (points[0].x != 0 || points[0].y != 0) throw "First point must be 0,0";
    if (points.at(-1).x != 1 || points.at(-1).y != 1) throw "Last point must be 1,1";
    const spreadPoints = Array.from({ length: spread - 1 }, (_, i) => ({ x: (i + 1) / spread, y: null }));
    const allPoints = [...points, ...spreadPoints].sort((a, b) => a.x - b.x);
    const res = [points[0]];
    for (let i = 1; i < allPoints.length - 1; i++) {
      const now = allPoints[i];
      if (now.y == null) {
        const before = allPoints[i - 1], after = allPoints[i + 1];
        const ratio = (now.x - before.x) / (after.x - before.x);
        now.y = before.y + (after.y - before.y) * ratio;
        res.push(now);
      }
    }
    res.push(points.at(-1));
    return res.map(p => p.y);
  }

  function bezier(curve, density = 100) {
    return spreadYValues(getTPoints(curve, density * 5), density);
  }

  function calcEndAccelerationAngle(bezierPoints) {
    const { x, y } = getTPoints([0, 0, ...bezierPoints, 1, 1]).at(-2);
    return Math.atan2(1 - y, 1 - x);
  }

  function numFixed(decimals, p) {
    decimals = 10 ** decimals;
    return Math.round(p * decimals) / decimals;
  }

  function rotateXY(x, y, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return { x: x * cos - y * sin, y: x * sin + y * cos };
  }

  const makeBezierHalf = function (ar) {
    return function bezierHalf(x, y, angleAdjust) {
      if (Math.abs(angleAdjust) > Math.PI / 6) //30deg
        throw new SyntaxError("Angle difference too large for smoothing.");

      if (Math.abs(angleAdjust) > .1 ** 10) {
        //rotate the control points if necessary around (0,0) and (1,1) respectively
        //the first point is only rotate half way, the second point is rotated to match fully
        const { x: x1, y: y1 } = rotateXY(ar[0], ar[1], angleAdjust / 2);
        const { x: x2, y: y2 } = rotateXY(1 - ar[2], 1 - ar[3], angleAdjust);
        ar = [x1, y1, 1 - x2, 1 - y2];
      }
      //scale the points to fit the box
      const ar3 = ar.map((v, i) => v * (i ? y : x));
      //end result full bezier
      const ar4 = [0, 0, ...ar3, x, y];
      const numberOfSlices = Math.ceil(500 * x);
      return getTPoints(ar4, numberOfSlices);
    }
  }

  const HALVES = {
    Fast: { curve: makeBezierHalf([0.85, 0.02, 0.96, 0.79]), width: .4, height: .5, acc: calcEndAccelerationAngle([0.85, 0.02, 0.96, 0.79]) },
    Back: { curve: makeBezierHalf([0.59, -0.26, 0.74, 0.05]), width: .5, height: .5, acc: calcEndAccelerationAngle([0.59, -0.26, 0.74, 0.05]) },
  };

  const findMiddle = (In, Out) =>
    In == null && Out == null ? .5 :
      Out == null ? In :
        In == null ? 1 - Out :
          (In + (1 - Out)) / 2;

  const COMPOSITES = {}
  for (let [In, { curve: cIn, width: wIn, height: hIn, acc: accIn }] of Object.entries(HALVES)) {
    for (let [Out, { curve: cOut, width: wOut, height: hOut, acc: accOut }] of Object.entries(HALVES)) {
      if (Out == In) Out = '';
      const name = `${In.toLowerCase()}In${Out}Out`;
      const x = findMiddle(wIn, wOut);
      const y = findMiddle(hIn, hOut);
      const acc = (accIn + accOut) / 2;
      // debugger
      const pointsIn = cIn(x, y, acc - accIn);
      const pointsOut1 = cOut(1 - x, 1 - y, acc - accOut);
      const pointsOut = pointsOut1
        .reverse()
        .slice(1) //we skip the overlapping middle point
        .map(({ x, y }) => ({ x: 1 - x, y: 1 - y }));
      const curve = spreadYValues([...pointsIn, ...pointsOut], 100);
      COMPOSITES[name] = { curve, width: x, height: y, acc, In, Out };
    }
  }

  //write a test for this function to verify it produces correct cubic-bezier values
  const TESTS = {
    "ease": {
      curve: bezier([0, 0, 0.25, 0.1, 0.25, 1.0, 1, 1], 100),
      test: [0, 0.004, 0.01, 0.017, 0.024, 0.033, 0.043, 0.054, 0.066, 0.08, 0.095, 0.111, 0.128, 0.146, 0.165, 0.185, 0.206, 0.228, 0.25, 0.273, 0.295, 0.318, 0.341, 0.364, 0.386, 0.409, 0.43, 0.452, 0.473, 0.493, 0.513, 0.533, 0.552, 0.57, 0.588, 0.605, 0.621, 0.637, 0.653, 0.668, 0.683, 0.697, 0.71, 0.723, 0.736, 0.748, 0.76, 0.771, 0.782, 0.792, 0.802, 0.812, 0.822, 0.831, 0.839, 0.848, 0.856, 0.864, 0.871, 0.878, 0.885, 0.892, 0.898, 0.904, 0.91, 0.916, 0.921, 0.927, 0.931, 0.936, 0.941, 0.945, 0.949, 0.953, 0.957, 0.96, 0.964, 0.967, 0.97, 0.973, 0.976, 0.978, 0.981, 0.983, 0.985, 0.987, 0.989, 0.99, 0.992, 0.993, 0.994, 0.995, 0.996, 0.997, 0.998, 0.999, 0.999, 1, 1, 1, 1]
    },
    "esae": {
      curve: bezier([0, 0, 0.25, 0.1, 0.25, 1.0, 1, 1], 100).reverse().map(y => Math.round((1 - y) * 1000) / 1000),
      test: [0, 0, 0, 0, 0.001, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.01, 0.011, 0.013, 0.015, 0.017, 0.019, 0.022, 0.024, 0.027, 0.03, 0.033, 0.036, 0.04, 0.043, 0.047, 0.051, 0.055, 0.059, 0.064, 0.069, 0.073, 0.079, 0.084, 0.09, 0.096, 0.102, 0.108, 0.115, 0.122, 0.129, 0.136, 0.144, 0.152, 0.161, 0.169, 0.178, 0.188, 0.198, 0.208, 0.218, 0.229, 0.24, 0.252, 0.264, 0.277, 0.29, 0.303, 0.317, 0.332, 0.347, 0.363, 0.379, 0.395, 0.412, 0.43, 0.448, 0.467, 0.487, 0.507, 0.527, 0.548, 0.57, 0.591, 0.614, 0.636, 0.659, 0.682, 0.705, 0.727, 0.75, 0.772, 0.794, 0.815, 0.835, 0.854, 0.872, 0.889, 0.905, 0.92, 0.934, 0.946, 0.957, 0.967, 0.976, 0.983, 0.99, 0.996, 1],
    }
  };

  function drawFunction(points, i = 5) {
    const canvas = document.createElement("canvas");
    const padding = 10 * i;
    canvas.width = 2 * padding + 50 * i;
    canvas.height = 2 * padding + 50 * i;
    const ctx = canvas.getContext("2d");
    ctx.lineWidth = 3;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "black";
    ctx.beginPath();
    ctx.moveTo(padding, padding + 50 * i);
    for (let p of points)
      ctx.lineTo(padding + p.x * 50 * i, padding + (50 * i - p.y * 50 * i));
    ctx.stroke();
    return canvas;
  }

  function runTest(name, curve, expected) {
    const resStr = curve.map(numFixed.bind(null, 3)).join(",");
    const expectedStr = expected?.join(","); // use emoji
    const result = resStr === expectedStr ? "✅" : "❌";
    if (result === "❌") {
      console.error("FAILED", name);
      console.log("Expected:", expectedStr);
      console.log("Got     :", resStr);
    }
    document.body.insertAdjacentHTML("beforeend",
      `<div style="transition-timing-function: linear(${resStr})">${name + result}</div>`);
    document.body.lastElementChild.append(
      drawFunction(curve.map((y, i) => ({ x: i / curve.length, y })))
    );
  }

  for (let [name, { curve, test }] of Object.entries({ ...COMPOSITES, ...TESTS }))
    runTest(name, curve, test);


</script>