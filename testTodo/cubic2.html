<style>
  body:hover div {
    transform: translateX(400px);
  }

  canvas {
    display: block;
  }

  div {
    transition-duration: 5s;
    transition-property: transform;
    width: fit-content;
    background: lightblue;
    margin: 10px;
    border: 1px solid blue;
    display: flex;
  }
</style>
<h1>hello sunshine</h1>


<script>
  class Transitions {

    static cubicBezier([x1, y1, x2, y2], sampleSize = 240, precision = 5) {
      if (![x1, y1, x2, y2].every(Number.isFinite))
        throw new TypeError("Control points must be finite numbers.");
      if (precision < 3)
        throw new RangeError("precision must be ≥ 2 (recommend ≥ 3).");

      const xInc = 1 / sampleSize;
      const tInc = xInc / precision;
      const res = new Array(sampleSize + 1);
      res[0] = 0;
      for (let xStep = xInc, prevX = 0, prevY = 0, t = 0, n = 1; t < 1; t += tInc) {
        const u = 1 - t;
        const tt = t * t;
        const ttt = tt * t;
        const uut3 = 3 * u * u * t, utt3 = 3 * u * tt;
        const x = uut3 * x1 + utt3 * x2 + ttt;
        const y = uut3 * y1 + utt3 * y2 + ttt;
        if (x >= xStep) {
          res[n++] = prevY + (y - prevY) * ((xStep - prevX) / (x - prevX));
          xStep += xInc;
        }
        prevX = x, prevY = y;
      }
      if (res.length < sampleSize)
        return this.cubicBezier([x1, y1, x2, y2], sampleSize, precision * 2);
      res[res.length - 1] = 1; //x=1, y=1
      return res;
    }

    static computeDecay(count, height, hDecay) {
      const timeDecay = Math.sqrt(hDecay);
      let time = 1 / ((1 - Math.pow(timeDecay, count)) / (1 - timeDecay));
      const res = [];
      for (let i = 0; i < count; i++, height *= hDecay, time *= timeDecay)
        res.push({ height, time });
      return res;
    }

    static bounce(count, firstHeight, decay = 0.7, width = 120) {
      if (count % .5 != 0)
        throw new RangeError("count must be whole or half numbers.");
      const overshoot = count % 1;
      const steps = this.computeDecay(Math.ceil(count), firstHeight, decay);
      const overshootScale = 1 + (steps[0].time / 2);

      const pointSet = steps.flatMap(({ time, height }) => {
        const halfSize = Math.round(time * .5 * width * overshootScale);
        const half = this.cubicBezier([0, 0, .58, 1], halfSize).map(y => y * height);
        return [half, half.slice().reverse().slice(1)];
      });
      overshoot && pointSet.shift();
      return pointSet.flat();
    }

    static sineWave(count, height, decay, width = 120) {
      return Array.from({ length: width + 1 }, (_, i) =>
        -Math.sin((i / width) * Math.PI * 2 * count) * height *
        Math.cos((Math.PI / 2) * (i / width))
      );
    }

    static CURVE = {
      slowIn: [.3, 0, 1, 1],   // gentle "ease-in"
      easeIn: [.42, 0, 1, 1],
      quickIn: [.55, 0, 1, 1], // stronger "ease-in"
      slowOut: [0, 0, .7, 1],  // gentle "ease-out"
      easeOut: [0, 0, .58, 1],
      quickOut: [0, 0, .45, 1],// stronger "ease-out"
    };

    static get WAVES() {
      return {
        easeIn: this.cubicBezier(this.CURVE.easeIn, 50),
        easeOut: this.cubicBezier(this.CURVE.easeOut, 50),
        easeInOut: this.cubicBezier([.42, 0, .58, 1], 50),
        easeInStrong: this.cubicBezier([.55, 0, 1, 1], 50),
        easeOutStrong: this.cubicBezier([0, 0, .45, 1], 50),
        easeInOutStrong: this.cubicBezier([.55, 0, .45, 1], 50),
        easeInSpringOut: [
          ...this.cubicBezier(this.CURVE.easeIn, 70),
          ...this.sineWave(2, .1, 1.3, 40).map(y => 1 - y).slice(1)
        ],
        bounce: this.bounce(3.5, 1, 0.4).map(y => 1 - y),
        easeInBounceOut: [
          ...this.cubicBezier(this.CURVE.easeIn, 100),
          ...this.bounce(3, .2, 0.7, 50).map(y => 1 - y)
        ],
        easeInBackOut: [
          ...this.cubicBezier(this.CURVE.easeIn, 70),
          ...this.sineWave(1, .1, 1.2, 40).map(y => y - 1).slice(1)
        ],
        fastInBumpOut: [
          ...this.cubicBezier(this.CURVE.slowIn, 90),
          ...this.bounce(1, .1, 0.5, 20).map(y => 1 - y)
        ],
      }
    }
  }




  function drawFunction(points, i = 250) {
    const canvas = document.createElement("canvas");
    const padding = i / 5;
    canvas.width = 2 * padding + i;
    canvas.height = 2 * padding + i;
    const ctx = canvas.getContext("2d");
    ctx.lineWidth = 3;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 6, 0, 2 * Math.PI);
    ctx.fill();
    let c = 0;
    for (let p = 0; p < points.length; p++) {
      const y = points[p];
      const x = p / (points.length - 1);
      ctx.fillStyle = c++ % 2 ? "green" : "black";
      ctx.beginPath();
      ctx.arc(padding + x * i, padding + (i - y * i), 2, 0, 2 * Math.PI);
      ctx.fill();
    }
    return canvas;
  }

  function numFixed(decimals, p) {
    decimals = 10 ** decimals;
    return Math.round(p * decimals) / decimals;
  }
  function runTest(name, curve, expected) {
    const resStr = curve.map(numFixed.bind(null, 3)).join(",");
    const expectedStr = expected?.join(","); // use emoji
    const result = resStr === expectedStr ? "✅" : "❌";
    if (result === "❌") {
      console.error("FAILED", name);
      console.log("Expected:", expectedStr);
      console.log("Got     :", resStr);
    }
    document.body.append(document.createElement("hr"));
    document.body.append(drawFunction(curve));
    document.body.insertAdjacentHTML("beforeend",
      `<div style="transition-timing-function: linear(${resStr})">${name + result}</div>`);
  }
  for (let [name, curve] of Object.entries(Transitions.WAVES))
    runTest(name, curve);
</script>