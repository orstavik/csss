<style>
  body:hover div {
    transform: translateX(400px);
  }

  canvas {
    display: block;
  }

  div {
    transition-duration: 5s;
    transition-property: transform;
    width: fit-content;
    background: lightblue;
    margin: 10px;
    border: 1px solid blue;
    display: flex;
  }
</style>
<h1>hello sunshine</h1>


<script>

  function sampleCubicBezierX([x1, y1, x2, y2], sampleSize = 240, precision = 5) {
    if (![x1, y1, x2, y2].every(Number.isFinite))
      throw new TypeError("Control points must be finite numbers.");
    if (precision < 3)
      throw new RangeError("precision must be ≥ 2 (recommend ≥ 3).");

    const xInc = 1 / sampleSize;
    const tInc = xInc / precision;
    const res = new Array(sampleSize + 1);
    res[0] = 0;
    for (let xStep = xInc, prevX = 0, prevY = 0, t = 0, n = 1; t < 1; t += tInc) {
      const u = 1 - t;
      const tt = t * t;
      const ttt = tt * t;
      const uut3 = 3 * u * u * t, utt3 = 3 * u * tt;
      const x = uut3 * x1 + utt3 * x2 + ttt;
      const y = uut3 * y1 + utt3 * y2 + ttt;
      if (x >= xStep) {
        res[n++] = prevY + (y - prevY) * ((xStep - prevX) / (x - prevX));
        xStep += xInc;
      }
      prevX = x, prevY = y;
    }
    if (res.length < sampleSize)
      return sampleCubicBezierX([x1, y1, x2, y2], sampleSize, precision * 2);
    res[res.length - 1] = 1; //x=1, y=1
    return res;
  }

  function sampleSineWave(pinch = 1, sampleSize = 240) {
    return Array.from({ length: sampleSize + 1 }, (_, i) =>
      (Math.sin((i / sampleSize) * Math.PI) + 1) * pinch / 2);
    //  - Math.PI / 2
  }

  //todo I think we do this in the functions manually. It is easy enough.
  // function scaleCurve(points, scaleY) { return points.map(y => y * scaleY); }
  // function invertCurve(points) { return points.map(y => 1 - y).reverse(); }
  // function downSample(points, factor) {
  //   if ((points.length - 1) % factor != 0)
  //     throw new RangeError("points.length-1 must be divisible by factor");
  //   const res = Array(points.length / factor);
  //   for (let i = 0; i <= points.length; i += factor)
  //     res[j++] = points[i];
  //   return res;
  // }




  function bounce(bounceCount, firstHeight, heightDecay = 0.5, width = 120) {

    function computeBounceDurations(totalTime, bounceCount, height, heightDecay) {
      if (heightDecay <= 0 || heightDecay >= 1) throw new Error("Decay factor r_H must be between 0 and 1.");
      if (bounceCount < 1) throw new Error("Must have a bounce count of at least 1.");
      const timeDecay = Math.sqrt(heightDecay);
      const sum_rT = (1 - Math.pow(timeDecay, bounceCount)) / (1 - timeDecay);
      let time = totalTime / sum_rT;
      const res = [];
      for (let i = 0; i < bounceCount; i++) {
        res.unshift({ height, time: time / 2 }, { height, time: time / 2 });
        height *= heightDecay;
        time *= timeDecay;
      }
      return res;
    }

    const overshoot = 1 - bounceCount % 1;
    const bounces = computeBounceDurations(width, Math.ceil(bounceCount), firstHeight, heightDecay);
    const fractionOfRemoved = 1 + (bounces.at(-1).time * 2 * overshoot / width);
    for (let b of bounces)
      b.time = Math.round(b.time * fractionOfRemoved);

    const points = bounces.flatMap(({ time, height }, i) => {
      const half = sampleCubicBezierX([0, 0, .58, 1], time).map(y => y * height);
      return i % 2 ?
        half.reverse().slice(1) :
        half;
    });
    return !overshoot ? points :
      points.slice(0, -Math.round(bounces.at(-1).time * 2 * overshoot));
  }

  const WAVES = {
    bouncy2: bounce(3.5, 1, 0.5),
    easeIn: sampleCubicBezierX([0.42, 0, 1, 1], 50),
    easeOut: sampleCubicBezierX([0, 0, 0.58, 1], 50),

    one: sampleCubicBezierX([0.5, 0, 0.5, 1], 50),
    two: sampleCubicBezierX([0.6, 0.04, 0.82, 0.55], 50),
    three: sampleSineWave(1, 50),
    // bouncy: [
    //   ...oneBounce(30, 0.5),
    //   ...oneBounce(30, 0.25),
    //   ...oneBounce(30, 0.1)
    // ],
    // bouncy3: bounce(3.5, 1, 0.5),
  }


  // //turn into sine, as we are going to start from 0. and then we need to end with positive slope.
  // //todo do we need density
  // function getCosPoints(count, density = 500) {
  //   return Array.from({ length: density + 1 }, (_, i) => {
  //     const x = (i / density);
  //     const y = Math.cos(x * Math.PI * count * 2);
  //     return { x, y: y * (x ** 1.3) };
  //   });
  // }

  // //todo
  // //function bounce(count, width, density){ }

  // function cubicBezier([x0, y0, x1, y1, x2, y2, x3, y3], t) {
  //   const u = 1 - t;
  //   const tt = t * t, uu = u * u;
  //   const uuu = uu * u, ttt = tt * t;
  //   const uut3 = 3 * uu * t, utt3 = 3 * u * tt;
  //   const x = uuu * x0 + uut3 * x1 + utt3 * x2 + ttt * x3;
  //   const y = uuu * y0 + uut3 * y1 + utt3 * y2 + ttt * y3;
  //   return { x, y };
  // }

  // function getTPoints(curve, density = 500) {
  //   return Array.from({ length: density + 1 }, (_, i) => cubicBezier(curve, i / density));
  // }

  // function spreadYValues(points, spread = 100) {
  //   const spreadPoints = Array.from({ length: spread - 1 }, (_, i) => ({ x: (i + 1) / spread, y: null }));
  //   const allPoints = [...points, ...spreadPoints].sort((a, b) => a.x - b.x);
  //   const res = [points[0]];
  //   for (let i = 1; i < allPoints.length - 1; i++) {
  //     const now = allPoints[i];
  //     if (now.y == null) {
  //       const before = allPoints[i - 1], after = allPoints[i + 1];
  //       const ratio = (now.x - before.x) / (after.x - before.x);
  //       now.y = before.y + (after.y - before.y) * ratio;
  //       res.push(now);
  //     }
  //   }
  //   res.push(points.at(-1));
  //   return res.map(p => p.y);
  // }

  // function bezier(curve, density = 100) {
  //   return spreadYValues(getTPoints(curve, density * 5), density);
  // }

  // function calcEndAccelerationAngle(bezierPoints) {
  //   const { x, y } = getTPoints([0, 0, ...bezierPoints, 1, 1]).at(-2);
  //   return Math.atan2(1 - y, 1 - x);
  // }


  // function rotateXY(x, y, angle) {
  //   const cos = Math.cos(angle);
  //   const sin = Math.sin(angle);
  //   return { x: x * cos - y * sin, y: x * sin + y * cos };
  // }

  // function bezierHalf(ar, x, y, angleAdjust) {
  //   if (Math.abs(angleAdjust) > Math.PI / 4) //45deg
  //     throw new SyntaxError("Angle difference too large for smoothing.");
  //   if (Math.abs(angleAdjust) > .1 ** 10) {
  //     //rotate the control points if necessary around (0,0) and (1,1) respectively
  //     //the first point is only rotate half way, the second point is rotated to match fully
  //     const { x: x1, y: y1 } = rotateXY(ar[0], ar[1], angleAdjust / 2);
  //     const { x: x2, y: y2 } = rotateXY(1 - ar[2], 1 - ar[3], angleAdjust);
  //     ar = [x1, y1, 1 - x2, 1 - y2];
  //   }
  //   //scale the points to fit the box
  //   const ar3 = ar.map((v, i) => v * (i % 2 === 0 ? x : y));
  //   //end result full bezier
  //   const ar4 = [0, 0, ...ar3, x, y];
  //   const numberOfSlices = Math.ceil(500 * x);
  //   return getTPoints(ar4, numberOfSlices);
  // }

  // function elastic(x, y, acc) {
  //   const count = acc > 0.01 ? 2 : acc < -0.01 ? 3 : 1;
  //   return getCosPoints(count, 500 * x).map(p => ({ x: p.x * x, y: p.y * y }));
  // }

  // const HALVES = {
  //   // Fast: { curve: bezierHalf.bind(null,[0.85, 0.02, 0.96, 0.79]), width: .4, height: .5, acc: calcEndAccelerationAngle([0.85, 0.02, 0.96, 0.79]) },
  //   Fast: { curve: bezierHalf.bind(null, [0.5, 0.07, 1, 1]), width: .4 },
  //   // Back: { curve: bezierHalf.bind(null,[0.52, -0.31, 0.74, 0.6]), width: .5, height: .5, acc: calcEndAccelerationAngle([0.52, -0.31, 0.74, 0.6]) },
  //   Backk: { curve: bezierHalf.bind(null, [0.35, 0, 0.4, -0.5]), width: .5 },
  //   Elastic: { curve: elastic, height: 0, acc: Math.PI / 3 },
  //   // Bounce: { curve: bounce, width: 0.4, height: 0.4, acc: Math.PI / 3 },
  // };

  // const findCompromise = (In, Out) =>
  //   !In && !Out ? .5 :
  //     Out == 0 ? 1 :
  //       In == 0 ? 0 :
  //         !Out ? In :
  //           !In ? 1 - Out :
  //             (In + (1 - Out)) / 2;

  // const COMPOSITES = {}
  // for (let [In, { curve: cIn, width: wIn, height: hIn, acc: accIn }] of Object.entries(HALVES)) {
  //   for (let [Out, { curve: cOut, width: wOut, height: hOut, acc: accOut }] of Object.entries(HALVES)) {
  //     if (Out == In) Out = '';
  //     const name = `${In.toLowerCase()}In${Out}Out`;
  //     const x = findCompromise(wIn, wOut);
  //     const y = findCompromise(hIn, hOut);
  //     const acc = (accIn + accOut) / 2;
  //     console.log(`${In}In${Out}Out: x=${x}, y=${y}, hIn=${hIn}, hOut=${hOut}, 1-x=${1 - x}, 1-y=${1 - y}`);
  //     const pointsIn = cIn(x, y, acc - accIn);
  //     const pointsOut1 = cOut(1 - x, 1 - y, acc - accOut);
  //     const pointsOut = pointsOut1
  //       .reverse()
  //       .slice(1)
  //       .map(({ x, y }) => ({ x: 1 - x, y: 1 - y }));
  //     const curve = spreadYValues([...pointsIn, ...pointsOut], 100);
  //     COMPOSITES[name] = curve;
  //   }
  // }

  function drawFunction(points, i = 250) {
    const canvas = document.createElement("canvas");
    const padding = i / 5;
    canvas.width = 2 * padding + i;
    canvas.height = 2 * padding + i;
    const ctx = canvas.getContext("2d");
    ctx.lineWidth = 3;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 6, 0, 2 * Math.PI);
    ctx.fill();
    let c = 0;
    for (let p = 0; p < points.length; p++) {
      const y = points[p];
      const x = p / (points.length - 1);
      ctx.fillStyle = c++ % 2 ? "green" : "black";
      ctx.beginPath();
      ctx.arc(padding + x * i, padding + (i - y * i), 2, 0, 2 * Math.PI);
      ctx.fill();
    }
    return canvas;
  }

  function numFixed(decimals, p) {
    decimals = 10 ** decimals;
    return Math.round(p * decimals) / decimals;
  }
  function runTest(name, curve, expected) {
    const resStr = curve.map(numFixed.bind(null, 3)).join(",");
    const expectedStr = expected?.join(","); // use emoji
    const result = resStr === expectedStr ? "✅" : "❌";
    if (result === "❌") {
      console.error("FAILED", name);
      console.log("Expected:", expectedStr);
      console.log("Got     :", resStr);
    }
    document.body.append(document.createElement("hr"));
    document.body.append(drawFunction(curve));
    document.body.insertAdjacentHTML("beforeend",
      `<div style="transition-timing-function: linear(${resStr})">${name + result}</div>`);
  }
  for (let [name, curve] of Object.entries(WAVES))
    runTest(name, curve);


  // //write a test for this function to verify it produces correct cubic-bezier values
  // const TESTS = {
  //   "ease": {
  //     curve: bezier([0, 0, 0.25, 0.1, 0.25, 1.0, 1, 1], 100),
  //     test: [0, 0.004, 0.01, 0.017, 0.024, 0.033, 0.043, 0.054, 0.066, 0.08, 0.095, 0.111, 0.128, 0.146, 0.165, 0.185, 0.206, 0.228, 0.25, 0.273, 0.295, 0.318, 0.341, 0.364, 0.386, 0.409, 0.43, 0.452, 0.473, 0.493, 0.513, 0.533, 0.552, 0.57, 0.588, 0.605, 0.621, 0.637, 0.653, 0.668, 0.683, 0.697, 0.71, 0.723, 0.736, 0.748, 0.76, 0.771, 0.782, 0.792, 0.802, 0.812, 0.822, 0.831, 0.839, 0.848, 0.856, 0.864, 0.871, 0.878, 0.885, 0.892, 0.898, 0.904, 0.91, 0.916, 0.921, 0.927, 0.931, 0.936, 0.941, 0.945, 0.949, 0.953, 0.957, 0.96, 0.964, 0.967, 0.97, 0.973, 0.976, 0.978, 0.981, 0.983, 0.985, 0.987, 0.989, 0.99, 0.992, 0.993, 0.994, 0.995, 0.996, 0.997, 0.998, 0.999, 0.999, 1, 1, 1, 1]
  //   },
  //   "esae": {
  //     curve: bezier([0, 0, 0.25, 0.1, 0.25, 1.0, 1, 1], 100).reverse().map(y => Math.round((1 - y) * 1000) / 1000),
  //     test: [0, 0, 0, 0, 0.001, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.01, 0.011, 0.013, 0.015, 0.017, 0.019, 0.022, 0.024, 0.027, 0.03, 0.033, 0.036, 0.04, 0.043, 0.047, 0.051, 0.055, 0.059, 0.064, 0.069, 0.073, 0.079, 0.084, 0.09, 0.096, 0.102, 0.108, 0.115, 0.122, 0.129, 0.136, 0.144, 0.152, 0.161, 0.169, 0.178, 0.188, 0.198, 0.208, 0.218, 0.229, 0.24, 0.252, 0.264, 0.277, 0.29, 0.303, 0.317, 0.332, 0.347, 0.363, 0.379, 0.395, 0.412, 0.43, 0.448, 0.467, 0.487, 0.507, 0.527, 0.548, 0.57, 0.591, 0.614, 0.636, 0.659, 0.682, 0.705, 0.727, 0.75, 0.772, 0.794, 0.815, 0.835, 0.854, 0.872, 0.889, 0.905, 0.92, 0.934, 0.946, 0.957, 0.967, 0.976, 0.983, 0.99, 0.996, 1],
  //   }
  // };


  // for (let [name, { curve, test }] of Object.entries(TESTS))
  //   runTest(name, curve, test);


</script>