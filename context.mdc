---
description: 
globs: 
alwaysApply: false
---
---
description: Project Context
globs: 
alwaysApply: true
---
# CSSS (CSS Shorts) Project Context

## Overview
CSSS (CSS Shorts) is a CSS preprocessor engine that introduces two main concepts for simplified CSS authoring:

1.  **Dollar Shorts**: Shorthand syntax patterns that start with `$`. These are typically JavaScript functions (defined in `func.js`, `layout.js`, `palette.js`) that generate CSS property objects. For example, `$padding(1rem, 2rem)` calls a function to generate logical padding properties, and `$flex(cc)` calls a function to configure flexbox centering.

2.  **Supershorts (Defined with `=`):** A way to define custom shortcuts using the `=` syntax within `<style csss="...">` or `csss="..."` attributes. These definitions create wrapper functions using the internal `makeSuperShort` mechanism.
    *   **Simple Aliases (`$name = $short1$short2;`):** Creates a function that, when called (e.g., by using `$name` in a class), executes the original sequence (`$short1`, then `$short2`) using the main function registry (`this.shorts`). This correctly handles built-ins like `$block` or `$border` by interpreting them at runtime.
    *   **Parameterized Functions (`$name(arg) = $short1(arg);`):** Creates a function that accepts arguments. When called (e.g., `$name(value)`), it substitutes the provided arguments into the remembered definition and then executes the resulting sequence using the main function registry.
    *   **Media/Selector Aliases (`@name = @media...;`, `:name = :pseudo...;`):** These are simple string replacements stored separately and used for media query or selector substitutions.

The engine comes with "BuiltinSupers" (`BuiltinSupers.js`) - a set of predefined simple aliases (like `$name = ...`), which are also processed using the `makeSuperShort` mechanism during initialization.

## Core Components

### Parser System
- **Parser.js**: Main parser for CSSS syntax.
  - Handles parsing of dollar shorts and supershort definitions (`=`).
  - Contains `extractSuperShorts` to parse definitions.
  - Contains `makeSuperShort` to create function wrappers for `$`-based supershorts.
  - Contains `Expression.interpret` to execute dollar short functions (both built-in and those created by `makeSuperShort`).
- **BuiltinSupers.js**: Predefined simple aliases (`$name = ...`).
  - Loaded first and processed by `extractSuperShorts` / `makeSuperShort`.
  - Examples: `$bold = $fontWeight(bold);`, `$italic = $fontStyle(italic);`

### Function System
- **func.js**: Core CSS function implementations (borders, basic properties, transforms, filters, gradients, fonts).
- **layout.js**: Layout-specific function implementations (`$block`, `$flex`, `$grid`, `$_block`, etc.). Includes `display` logic and resets.
- **palette.js**: Color system and palette function implementations (`$palette`, `$color`, shadows, text decorations).

### Engine
- **engine.js**: Core processing engine.
  - Initializes (`this.shorts` with functions from `func.js`, `layout.js`, `palette.js`).
  - Reads and processes `BuiltinSupers.js` and other supershort definitions using `readSupers` -> `extractSuperShorts`. Stores resulting functions/aliases in `this.shorts` or `this.supers`.
  - Processes class attributes (`addRule`) by creating `ShortBlock` instances.
  - Interprets the shorts within a `ShortBlock` (`Expression.interpret`):
    - The first short (container) is interpreted using the global `this.shorts`.
    - Subsequent shorts (items, separated by `|`) are interpreted using the `itemScope` provided by the container's main function (e.g., `$grid` provides `$_grid` scope).
  - Handles CSS rule generation and insertion into the stylesheet layers (`container` and `items`).

## Key Features

### Dollar Shorts
Dollar shorts are direct calls to JavaScript functions that return CSS property objects.
```css
/* Using Dollar Shorts */
<div class = "$padding(1rem, 2rem) $flex(row, c)"></div>

/* Resulting CSS (Simplified) */
.\$padding\(1rem\,2rem\) { padding-block: 1rem; padding-inline: 2rem; }
.\$flex\(row\,c\) { display: flex; flex-direction: row; align-items: center; }
```

### Supershorts (`=`)
Supershorts create callable functions via `makeSuperShort`.
```css
/* Defining and Using Supershorts */
<style csss="
  /* Simple Alias (creates a function wrapper) */
  $cardBase = $border(solid, 1px)$padding(1rem);
  /* Parameterized Function */
  $rounded(r) = $border(radius(r));
">
</style>

<div class="$cardBase $rounded(8px)"></div>

/* How it works internally: */
/* 1. $cardBase definition creates a function in this.shorts['cardBase'] */
/* 2. $rounded definition creates a function in this.shorts['rounded'] */
/* 3. When class="$cardBase $rounded(8px)" is processed: */
/*    - this.shorts.cardBase() is called -> runs $border(solid, 1px), then $padding(1rem) */
/*    - this.shorts.rounded('8px') is called -> substitutes 'r', runs $border(radius('8px')) */

/* Resulting CSS (Simplified) */
.\$cardBase { border: solid 1px; padding: 1rem; }
.\$rounded\(8px\) { border-radius: 8px; }
```

### Item Scopes (`|`)
The `|` character separates container styles from item styles within a single class attribute. Item styles are interpreted within the specific `itemScope` provided by the container's primary layout function (e.g., `$grid` provides `$_grid`, `$flex` provides `$_flex`).

There are two main ways to apply item styles:

1.  **Direct Item Function Call (Preferred):** Call the item function directly.
    ```css
    /* Apply grid column styles to all direct children (*) */
    <div class="$grid(cols(3))|*$column(1, 3)"></div>

    /* How it works: */
    /* 1. $grid(cols(3)) is interpreted in the global scope, sets display:grid */
    /*    and provides the $_grid object as the itemScope. */
    /* 2. $column(1, 3) is interpreted using the $_grid itemScope, */
    /*    which finds and executes the column() function. */

    /* Resulting CSS (Simplified) */
    .\$grid\(cols\(3\)\)\|\*\$column\(1\,3\) { display: grid; grid-template-columns: repeat(3, 1fr); }
    .\$grid\(cols\(3\)\)\|\*\$column\(1\,3\) > * { grid-column: 1 / 3; }
    ```

2.  **Using Item Scope Function (Redundant but Works):** Explicitly call the item scope function (`$_grid`, `$_flex`, etc.).
    ```css
    /* Apply grid column styles using the explicit $_grid function */
    <div class="$grid(cols(3))|*$_grid(column(1, 3))"></div>

    /* How it works: */
    /* 1. Same as above, $_grid is the itemScope. */
    /* 2. $_grid(column(1, 3)) is interpreted using the $_grid itemScope. */
    /* 3. The $_grid function itself is called and processes its arguments, */
    /*    eventually calling the column() function. */
    ```

3.  **Using Supershorts:** Reference a defined supershort.
    ```css
    /* Define item styles as supershorts */
    <main csss="
      $hg = $grid(rows(auto,1fr,auto),cols(auto,1fr,auto));
      $hg.header = $column(1,4);
      $hg.main = $column(2,3);
    ">
      <div class="$hg|header$header|main$main">...</div>
    </main>

    /* How it works: */
    /* 1. $hg sets the context and provides the $_grid itemScope. */
    /* 2. For |header$header: */
    /*    - The selector is 'header'. */
    /*    - The short is '$header'. */
    /*    - The engine looks up the supershort $hg.header ($column(1,4)). */
    /*    - $column(1,4) is interpreted using the $_grid itemScope. */
    /* 3. Similar process for |main$main. */
    ```

### BuiltinSupers System (`BuiltinSupers.js`)
- Provides a default set of simple aliases (like `$bold`, `$italic`).
- These are also converted into function wrappers via `makeSuperShort` on initialization.
- Example: `$bold` in a class calls the function created from `$bold = $fontWeight(bold);`, which in turn calls the actual `$fontWeight` function.

## Color System and Palettes
```css
/* Using $palette to define a color scheme */
.\$palette\(\#d41c84\) {
    /* Sets primary color and generates secondary, tertiary, and neutral colors */
}

/* Using $color with palette colors and modifiers */
.element {
  $color(primary)           /* Use primary color */
  $color(primary-box)      /* Primary color with box relief */
  $color(primary-flip)     /* Primary color with flip relief */
  $color(neutral-box)      /* Neutral color with box relief */
  $color(red-blend-box)    /* Red color blended with box relief */
}
```

The palette system provides:
- **Color Roles**: primary, secondary, tertiary, and neutral colors
- **Color Reliefs**: bw (black/white), text, box, flip, darkflip
- **Color Blending**: Support for red, green, orange, blue with blend modifiers
- **Border Intensities**: b0 through b9 for fine-tuned border colors
- **Special Effects**: pop and blend modifiers for enhanced color effects

Each palette color can be combined with various modifiers:
- Relief types (box, flip, darkflip)
- Border intensities (b0-b9)
- Special effects (pop, blend)
- Color mixing and blending

## Testing
- HTML-based test files in `/test`
- HappyPath tests for feature verification
- Color analysis tools in `/color_analysis`
- PaletteGuide for full palette guidebook

## Current State
1. Recent Changes:
   - Refactored supershort handling (`=`) to use `makeSuperShort`, creating function wrappers. This enables parameterized definitions (`$name(arg) = ...`) and correctly handles built-in shorts within definitions at runtime.
   - Clarified item scope (`|`) handling: Item styles (`selector$short`) are now interpreted using the specific `itemScope` provided by the container's layout function (e.g., `$grid` provides `$_grid`). The preferred syntax is to call item functions directly (e.g., `|$column(1,3)`) rather than wrapping them (e.g., `|$_grid(column(1,3))`).
   - Moved layout-specific functions (`$block`, `$grid`, `$flex`, `$_block`, etc.) including `display` logic into `layout.js`.
   - Cleaned up function/alias storage (`this.shorts` for functions, `this.supers` for `@`/`:` aliases).

2. Active Issues:
   - Supershorts system complexity: The current supershorts system is overly complex and planned for replacement with a more direct custom word approach. This will simplify the syntax and make it more consistent with how colors work.
   
   - Media query handling: Plans to implement media queries as shorts (e.g., `@md`, `@dark`) with a consistent expression syntax, making them more aligned with the rest of the CSSS system.
   
   - Smart loading system: Implementing an "upgrade" sequence where the system doesn't fail on unregistered shorts but stores them for later when they become available.
   
   - Layout naming conventions: Working toward a more semantic layout system with named layouts (e.g., `$grid(holyGrail)`), allowing complex layouts to be defined with single words.
   
   - Single registry consolidation: Moving toward a single unified registry that includes both $ and @ shorts with their prefixes, simplifying the system architecture.

3. Ongoing Work:
   - Enhancing test coverage
   - Fixing Bugs
   - Adding more built-in supers
   - Adding more missing functions in the engine

## Development Setup
```bash
# Start development server
npx http-server -p 3003 --cors

# Access tests
https://127.0.0.1:3003:/test/index

#Specific test file
https://127.0.0.1:3003:/test/index#HappyPathName
```

## File Structure
```
csss/
├── src/
│   ├── Parser.js         # Main parser
│   ├── func.js          # Core functions
│   ├── BuiltinSupers.js # Predefined supershorts
│   ├── engine.js        # Processing engine
│   ├── layout.js        # Layout utilities
│   ├── palette.js       # Color palette tools
│   └── Color.js         # Color utilities
├── test/
│   └── HappyPath*.html  # Feature tests
├── color_analysis/      # Color tools
└── csss-properties-reference.md
```